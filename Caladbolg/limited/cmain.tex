\documentclass[landscape, oneside, a4paper, cs4size]{book}

\def\marginset#1#2{                      % 页边设置 \marginset{left}{top}
\setlength{\oddsidemargin}{#1}         % 左边（书内侧）装订预留空白距离
\iffalse                   % 如果考虑左侧（书内侧）的边注区则改为\iftrue
\reversemarginpar
\addtolength{\oddsidemargin}{\marginparsep}
\addtolength{\oddsidemargin}{\marginparwidth}
\fi
\setlength{\evensidemargin}{0mm}       % 置0
\iffalse                   % 如果考虑右侧（书外侧）的边注区则改为\iftrue
\addtolength{\evensidemargin}{\marginparsep}
\addtolength{\evensidemargin}{\marginparwidth}
\fi
% \paperwidth = h + \oddsidemargin+\textwidth+\evensidemargin + h
\setlength{\hoffset}{\paperwidth}
\addtolength{\hoffset}{-\oddsidemargin}
\addtolength{\hoffset}{-\textwidth}
\addtolength{\hoffset}{-\evensidemargin}
\setlength{\hoffset}{0.5\hoffset}
\addtolength{\hoffset}{-1in}           % h = \hoffset + 1in
%\setlength{\voffset}{-1in}             % 0 = \voffset + 1in
\setlength{\topmargin}{\paperheight}
\addtolength{\topmargin}{-\headheight}
\addtolength{\topmargin}{-\headsep}
\addtolength{\topmargin}{-\textheight}
\addtolength{\topmargin}{-\footskip}
\addtolength{\topmargin}{#2}           % 上边预留装订空白距离
\setlength{\topmargin}{0.5\topmargin}
}
% 调整页边空白使内容居中，两参数分别为纸的左边和上边预留装订空白距离
\marginset{125mm}{200mm}


%\usepackage{ctex}
\usepackage{bm}
%\usepackage[fleqn]{amsmath}
\usepackage{harpoon}
\usepackage{fontspec}
\usepackage{listings}
\usepackage[left=1cm,right=1cm,top=1cm,bottom=1cm,columnsep=1cm,dvipdfm]{geometry}
\usepackage{setspace}
\usepackage{bm}
\usepackage{cmap}
\usepackage{cite}
\usepackage{float}
\usepackage{xeCJK}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{setspace}
\usepackage{enumerate}
\usepackage{indentfirst}
\usepackage{adjmulticol}
\usepackage{titlesec}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage[cache=false]{minted}
\usepackage{pdfpages}
\allowdisplaybreaks
%\setlength{\parindent}{0em}
%\setlength{\mathindent}{0pt}
\lstset{breaklines}
\let\cleardoublepage\relax
\titleformat{\chapter}{\normalfont\large\bfseries}{第\,\thechapter\,章}{10pt}{\large}
\titleformat{\section}{\normalfont\normalsize\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\small\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\footnotesize\bfseries}{\thesubsubsection}{1em}{}
\titlespacing*{\chapter} {0pt}{0pt}{0pt}
\titlespacing*{\section} {0pt}{0pt}{0pt}
\titlespacing*{\subsection} {0pt}{-1pt}{-1pt}
\titlespacing*{\subsubsection}{0pt}{-1pt}{-1pt}
\newfontfamily\Courier{Courier 10 Pitch}

\renewcommand{\theFancyVerbLine}{\rmfamily\scriptsize\arabic{FancyVerbLine}}
\newcommand{\cppcode}[1]{
    \inputminted[mathescape,
    			 tabsize=2,
    			 linenos,
    			 %frame=single,
    			 framesep=2mm,
    			 breakaftergroup=true,
    			 breakautoindent=true,
    			 breakbytoken=true,
    			 breaklines=true,
    			 fontsize=\scriptsize
    ]{cpp}{source/#1}
}
\newcommand{\javacode}[1]{
    \inputminted[mathescape,
    			 tabsize=2,
    			 linenos,
    			 %frame=single,
    			 framesep=2mm,
    			 breakaftergroup=true,
    			 breakautoindent=true,
    			 breakbytoken=true,
    			 breaklines=true,
    			 fontsize=\scriptsize
    ]{java}{source/#1}
}
\newcommand{\vimcode}[1]{
    \inputminted[mathescape,
    			 tabsize=2,
    			 linenos,
    			 %frame=single,
    			 framesep=2mm,
    			 breakaftergroup=true,
    			 breakautoindent=true,
    			 breakbytoken=true,
    			 breaklines=true,
    			 fontsize=\footnotesize
    ]{vim}{source/#1}
}
\begin{document}
	\title{\textbf{\LARGE{Standard Code Library}}}
	\author{Shanghai Jiao Tong University, Caladbolg}
	%\maketitle
	\begin{multicols}{2}\small
	\begin{spacing}{0.72}
	\tableofcontents
		\chapter{李沐阳}
		\section{AC自动机}
			\cppcode{lmy/AC自动机.cpp}
		\section{Dinic Algorithm}
			\cppcode{lmy/Dinic Algorithm.cpp}
		\section{K-Dimension Tree}
			\cppcode{lmy/K-Dimension Tree.cpp}
		\section{KM}
			\cppcode{lmy/KM.cpp}
		\section{Link Cut Tree}
			\cppcode{lmy/Link Cut Tree.cpp}
		\section{Numerical Integration}
			\cppcode{lmy/Numerical Integration.cpp}
		\section{Splay}
			\cppcode{lmy/Splay.cpp}
		\section{几何基础}
			\cppcode{lmy/几何基础.cpp}
		\section{凸包}
			\cppcode{lmy/凸包.cpp}
		\section{无向图最小割}
		\cppcode{Graph-Algorithm/Minimum-Cut-Stoer-Wagner.cpp}
		\section{匈牙利}
			\cppcode{lmy/匈牙利.cpp}
		\section{半平面交}
			\cppcode{lmy/半平面交.cpp}
		\section{后缀数组}
			\cppcode{lmy/后缀数组.cpp}
		\section{圆与多边形面积交}
			\cppcode{lmy/圆与多边形面积交.cpp}
		\section{圆的K次交}
			\cppcode{lmy/圆的K次交.cpp}
		\section{最小覆盖圆}
		\cppcode{Geometry-Algorithm/Minimum-Coverage-Circle.cpp}
		\section{三维凸包}
		\cppcode{Geometry-Algorithm/Convex-Hull-3D.cpp}
		\section{三维绕轴旋转}
		\noindent \textbf{注意事项：}以右手拇指为向量方向，逆时针绕轴（剩下四根手指方向）旋转$\theta$角的右乘矩阵。
		\cppcode{Geometry-Algorithm/Rotate-3D.cpp}
		\section{平面图}
			\cppcode{lmy/平面图.cpp}
		\section{弦图染色最大势}
			\cppcode{lmy/弦图染色最大势.cpp}
		\section{强连通分量}
			\cppcode{lmy/强连通分量.cpp}
		\section{支配树}
			\cppcode{lmy/支配树.cpp}
		\section{点双联通分量}
			\cppcode{lmy/点双联通分量.cpp}
		\section{线性规划}
			\cppcode{lmy/线性规划.cpp}
		\section{费用流}
			\cppcode{lmy/费用流.cpp}
		\section{直线下整点个数}
		\noindent \textbf{注意事项：}返回结果为：$\displaystyle \sum_{0 \leq i < n} \lfloor \frac{a + b \cdot i}{m} \rfloor$
		即直线下整点个数。
		\cppcode{Mathematical-Algorithm/Lattice-Counter.cpp}
		\section{闪电素数判定}
		\cppcode{Mathematical-Algorithm/Miller-Rabin.cpp}
		\section{闪电质因数分解}
		\cppcode{Mathematical-Algorithm/Pollard-Rho.cpp}
		\section{⾃适应⾟普森}
		\cppcode{Mathematical-Algorithm/Self-Adjusting-Simpson.cpp}
	\chapter{孙司宇}
		\section{FFT} \cppcode{ssy/FFT.cpp}
		\section{NTT} \cppcode{ssy/NTT.cpp}
		\section{SAM} \cppcode{ssy/SAM.cpp}
		\section{manacher} \cppcode{ssy/manacher.cpp}
		\section{中国剩余定理} \cppcode{ssy/中国剩余定理.cpp}
		\section{回文自动机} \cppcode{ssy/回文自动机.cpp}
		\section{多项式开方} \cppcode{ssy/多项式开方.cpp}
		\section{多项式求逆} \cppcode{ssy/多项式求逆.cpp}
		\section{广义SAM} \cppcode{ssy/广义SAM.cpp}
		\section{循环串最小表示} \cppcode{ssy/循环串最小表示.cpp}
		\section{最大团搜索} \cppcode{ssy/最大团搜索.cpp}
		\section{求原根} \cppcode{ssy/求原根.cpp}
		\section{线性递推多项式} \cppcode{ssy/线性递推多项式.cpp}
		\section{经纬度球面距离} \cppcode{Incidental-Algorithm/Ball-Distance.cpp}
		\section{日期公式} \cppcode{Incidental-Algorithm/Date-Lemma.cpp}
		\section{Manacher} \noindent \textbf{注意事项：}1-based算法，请注意下标。 \cppcode{String-Algorithm/Manacher.cpp}
	\chapter{丁尧尧}
		\section{kth.shortest.path} \cppcode{dyy/kth.shortest.path.cpp}
		\section{弦图} \cppcode{dyy/弦图.cpp}
		\section{集合幂级数} \cppcode{dyy/集合幂级数.cpp}
	\chapter{其他}
		\section{Java Hints}
		\javacode{Hint/Java-Hints.java}
				\begin{spacing}{0.50}
					\section{常用结论}\footnotesize
					\begin{spacing}{0.5}
						\subsection*{上下界网络流}
						$B(u,v)$表示边$(u,v)$流量的下界，$C(u,v)$表示边$(u,v)$流量的上界，$F(u,v)$表示边$(u,v)$的流量。
						设$G(u,v) = F(u,v) - B(u,v)$，显然有：$\displaystyle 0 \leq G(u,v) \leq C(u,v)-B(u,v)$
						\subsubsection*{无源汇的上下界可行流}
						建立超级源点$S^*$和超级汇点$T^*$，对于原图每条边$(u,v)$在新网络中连如下三条边：$S^* \rightarrow v$，容量为$B(u,v)$；$u \rightarrow T^*$，容量为$B(u,v)$；$u \rightarrow v$，容量为$C(u,v) - B(u,v)$。最后求新网络的最大流，判断从超级源点$S^*$出发的边是否都满流即可，边$(u,v)$的最终解中的实际流量为$G(u,v)+B(u,v)$。
						\subsubsection*{有源汇的上下界可行流}
						从汇点$T$到源点$S$连一条上界为$\infty$，下界为$0$的边。按照\textbf{无源汇的上下界可行流}一样做即可，流量即为$T \rightarrow S$边上的流量。
						\subsubsection*{有源汇的上下界最大流}
						\begin{enumerate}
							\item 在\textbf{有源汇的上下界可行流}中，从汇点$T$到源点$S$的边改为连一条上界为$\infty$，下届为$x$的边。$x$满足二分性质，找到最大的$x$使得新网络存在\textbf{无源汇的上下界可行流}即为原图的最大流。
							\item 从汇点$T$到源点$S$连一条上界为$\infty$，下界为$0$的边，变成无源汇的网络。按照\textbf{无源汇的上下界可行流}的方法，建立超级源点$S^*$和超级汇点$T^*$，求一遍$S^* \rightarrow T^*$的最大流，再将从汇点$T$到源点$S$的这条边拆掉，求一次$S \rightarrow T$的最大流即可。
						\end{enumerate}
						\subsubsection*{有源汇的上下界最小流}
						\begin{enumerate}
							\item 在\textbf{有源汇的上下界可行流}中，从汇点$T$到源点$S$的边改为连一条上界为$x$，下界为$0$的边。$x$满足二分性质，找到最小的$x$使得新网络存在\textbf{无源汇的上下界可行流}即为原图的最小流。
							\item 按照\textbf{无源汇的上下界可行流}的方法，建立超级源点$S^*$与超级汇点$T^*$，求一遍$S^* \rightarrow T^*$的最大流，但是注意这一次不加上汇点$T$到源点$S$的这条边，即不使之改为无源汇的网络去求解。求完后，再加上那条汇点$T$到源点$S$上界$\infty$的边。因为这条边下界为$0$，所以$S^*$，$T^*$无影响，再直接求一次$S^* \rightarrow T^*$的最大流。若超级源点$S^*$出发的边全部满流，则$T \rightarrow S$边上的流量即为原图的最小流，否则无解。
						\end{enumerate}
						\subsection*{上下界费用流}
						\noindent \textbf{来源：BZOJ 3876}
						\noindent 设汇$t$，源$s$，超级源$S$，超级汇$T$，本质是每条边的下界为1，上界为$MAX$，跑一遍有源汇的上下界最小费用最小流。（因为上界无穷大，所以只要满足所有下界的最小费用最小流）
						\begin{enumerate}
							\item 对每个点$x$：从$x$到$t$连一条费用为0，流量为MAX的边，表示可以任意停止当前的剧情（接下来的剧情从更优的路径去走，画个样例就知道了）
							\item 对于每一条边权为$z$的边$x \rightarrow y$：
								\begin{itemize}
									\item 从$S$到$y$连一条流量为1，费用为$z$的边，代表这条边至少要被走一次。
									\item 从$x$到$y$连一条流量为$MAX$，费用为$z$的边，代表这条边除了至少走的一次之外还可以随便走。
									\item 从$x$到$T$连一条流量为1，费用为0的边。（注意是每一条$x->y$的边都连，或者你可以记下$x$的出边数$K_x$，连一次流量为$K_x$，费用为0的边）。
								\end{itemize}
						\end{enumerate}
						建完图后从S到T跑一遍费用流，即可。（当前跑出来的就是满足上下界的最小费用最小流了）
						\subsection*{弦图相关}
						\begin{enumerate}
							\item[1.] 团数 $\leq$ 色数 , 弦图团数 = 色数
							\item[2.] 设 $next(v)$ 表示 $N(v)$ 中最前的点 .
								令 w* 表示所有满足 $A \in B$ 的 w 中最后的一个点 ,
								判断 $v \cup N(v)$ 是否为极大团 ,
								只需判断是否存在一个 w,
								满足 $Next(w)=v$ 且 $|N(v)| + 1 \leq |N(w)|$ 即可 .
							\item[3.] 最小染色 : 完美消除序列从后往前依次给每个点染色 ,
								给每个点染上可以染的最小的颜色
							\item[4.] 最大独立集 : 完美消除序列从前往后能选就选
							\item[5.] 弦图最大独立集数 $=$ 最小团覆盖数 ,
								最小团覆盖 :
								设最大独立集为 $\{p_1,p_2, \dots ,p_t\}$,
								则 $\{p_1\cup N(p_1), \dots , p_t \cup N(p_t)\}$
								为最小团覆盖
						\end{enumerate}
						\subsection*{Bernoulli数}
						\input{source/Hint/Bernoulli-Number.tex}
					\end{spacing}
					\section{常见错误}\footnotesize
					\begin{enumerate}
						\item 数组或者变量类型开错，例如将double开成int；
						\item 函数忘记返回返回值；
						\item 初始化数组没有初始化完全；
						\item 对空间限制判断不足导致MLE
					\end{enumerate}
					\section{博弈游戏}\footnotesize
					\input{source/Hint/Game-Theory.tex}
					\section{常用数学公式}\footnotesize
					\input{source/Hint/Mathematical-Lemma.tex}
%			\end{spacing}
	%\includepdf[pages=-]{source/Appendix/cheat.pdf}
	\end{spacing}
		\section{附录}
		\subsection*{NTT素数及原根列表}
		\input{source/Appendix/NFT-Primes.tex}
	\end{spacing}
	\end{multicols}
\end{document}

